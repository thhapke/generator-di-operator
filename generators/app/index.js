var Generator = require('yeoman-generator');
var memFs = require("mem-fs");
var editor = require("mem-fs-editor");
var path = require("path");
var mkdirp = require('mkdirp')
const fs = require('fs');


// GLOBAL Variables
const operators_path = '/files/vflow/subengines/com/sap/python36/operators/';
const exclude_list = ['.git','.gitignore','LICENSE','README.md'];

//VCTL LOGIN
function _vctl_login(gen,di_url,tenant,user,pwd) {
  const vctl_login = ['login',di_url,tenant,user,'-p',pwd];
  gen.spawnCommandSync('vctl',vctl_login);
};

//VCTL LS
function _vctl_ls(gen,op_package) {
  let package_path = ''
  if (op_package == '.') {
    package_path = path.join(operators_path)
  }
  else {
    let operator_path = op_package.replace('.','/')
    package_path = path.join(operators_path,operator_path)
  };
  // call vctl
  const vctl_ls = ['vrep','user','ls',package_path];
  const vctl_ls_out = gen.spawnCommandSync('vctl',vctl_ls,{ stdio: [process.stdout] });
  let file_list = vctl_ls_out.stdout.split("\n");

  // extract list without exclusions
  let files = []
  file_list.forEach(function(item){
    let f = item.trim()
    if (exclude_list.includes(f) == false) {
      files.push(f);
    };
  });
  return files;
};  

// Read VCTL file
function _vctl_read(gen,operator_path) {
  const vctl_cat = ['vrep','user','cat',operator_path];
  const vctl_cat_out = gen.spawnCommandSync('vctl',vctl_cat,{stdio: [process.stdout] });
  return vctl_cat_out.stdout
};

// Put VCTL file
function _vctl_put(gen,source_path,operator_path) {
  const vctl_put = ['vrep','user','put',source_path,operator_path];
  gen.spawnCommandSync('vctl',vctl_put);
};



/*
 * Generator
*/
module.exports = class extends Generator {

  constructor(args,opts) {
    super(args,opts);

    //this.argument("init",{type: String,desc:'Initialize project by copying necessary files. Attention: overrides changed files!'})
    this.option("init",{type: Boolean,default:false,desc:'Initialize project by copying necessary files. Attention: overrides changed files!'});
    this.files_content = {};
    this.operator_dir = '';
  }
  
  async prompting() {
    this.answers = await this.prompt([
      {
        type: 'list',
        name: 'direction',
        message: 'Download or Upload operator',
        default: 'D',
        choices: [
          {
            name: 'Download',
            value: 'D',
          }, {
            name: 'Upload',
            value: 'U'
          }
        ]
      },
      {
        type: "input",
        name: "di_url",
        message: "SAP Data Intelligence URL",
        store: true // Default to current folder name
      },
      {
        type: "input",
        name: "tenant",
        message: "Tenant",
        default: "default",
        store: true
      },
      {
        type: "input",
        name: "user",
        message: "User",
        store: true
      },
      {
        type: "input",
        name: "pwd",
        message: "Password",
        store: true
      },
      {
        type: "input",
        name: "operator",
        message: "Operator",
        store: true
      }
    ]);

    //this.answers.direction = this.answers.direction.toUpperCase();
    this.operator_dir = this.answers.operator.replace('.','/');

    //login
    this.log('Login into SAP Data Intelligence')
    _vctl_login(this,this.answers.di_url,this.answers.tenant,this.answers.user,this.answers.pwd);

    if (this.answers.direction =='D') {
      this.log('***** Download *****');
      // List all files in operator folder
      let files = _vctl_ls(this,this.answers.operator);
      //this.log('All files in \''+this.answers.operator+'\'-directory: ' + files)

      // copy files 
      for (let f = 0; f < files.length; f++ ) {
        // Download file and add to files_content dict
        let operator_path = path.join(operators_path,this.operator_dir,files[f]);
        this.log('Copy file: ' + files[f] )
        this.files_content[files[f]] = _vctl_read(this,operator_path);
      };
    };
  };

  
  writing() {

    /*
     *  Initializes Poject option --init
    */
    if (this.options.init) {
      this.log('Initializes project.')
      // make testdata directory
      mkdirp.sync(path.join(this.destinationRoot(),'operators'));
      // copying the mock_di_api and operator_test to utils
      this.fs.copy(this.templatePath('mock_di_api.py'),this.destinationPath('utils/mock_di_api.py'));
      this.fs.copy(this.templatePath('operator_test.py'),this.destinationPath('utils/operator_test.py'));
      // make testdata directory
      mkdirp.sync(path.join(this.destinationRoot(),'testdata'));
    };

    let import_mock_api = `# First 3 lines generated by di-pyoperator - DO NOT CHANGE (Deleted again when uploaded.)
from utils.mock_di_api import mock_api
api = mock_api(__file__)
`


    /******
     *  Download files from DI
    ******/
    if (this.answers.direction == 'D') {

      let config_att = JSON.parse(this.files_content['configSchema.json']);
      let op_att = JSON.parse(this.files_content['operator.json']);
      let script_file = '';
      if (op_att['config']['script'].match(/^file:\/\//)) {
        script_file = op_att['config']['script'].slice(7);
        this.log('Script file: '+script_file )
      } else {
        // extract inline code and change operator.json
        script_file = 'script.py';
        this.files_content[script_file] = op_att['config']['script'];
        op_att['config']['script'] = 'file://script.py';
        this.log(JSON.stringify(op_att));
        this.files_content['operator.json'] = JSON.stringify(op_att, null, 2);
      }
      //this.log('Root: ' + this.destinationRoot())
      let dest_path = path.join(this.destinationRoot(),'operators',this.operator_dir);
      this.log('Target directory: ' + dest_path);
      mkdirp(dest_path);

      // Test empty script -> no script
      /*
      if ((script_file in this.files_content)  && this.files_content[script_file].length < 20) {
        this.log('Script exist but has not content. Will be overwritten!')
        delete this.files_content[script_file]
      }
      */
      /***************** 
       * python script
      *****************/
      if ((script_file in this.files_content) === false)   {
        /*
        * NEW python script
        */
        this.log('Script file not found: ' + script_file + '  -> New scriptfile created! ');
        // import mock-di-api
        let script_content = import_mock_api + '\n\n';

        // generator or callback
        let call_func = ''
        if (('inports' in op_att) === false || op_att['inports'].length == 0) {
          call_func = 'gen()';
          script_content += 'def '+call_func+' :\n\tpass\n\n';
          script_content += 'api.add_generator(gen)';
        } else {
          for (let ip = 0; ip < op_att['inports'].length; ip++) {
            //this.log('Inport: ' + op_att['inports'][ip]['name']);
            call_func = 'on_'+op_att['inports'][ip]['name']+'(msg)'
            script_content += 'def ' + call_func+' :\n\n';
            for (let op = 0; op < op_att['outports'].length; op++) {
              //this.log('Outport: ' + op_att['outports'][op]['name']);
              script_content += '\tout_msg = None\n';
              script_content += '\tapi.send(\''+op_att['outports'][op]['name']+'\',out_msg)\n\n';
            }
            script_content += 'api.set_port_callback(\''+op_att['inports'][ip]['name']+'\',on_'+op_att['inports'][ip]['name']+')\n\n';
          }
        };
        this.files_content[script_file] = script_content;
      } else  {
      /*
       * ADJUST python script
      */ 
        this.log('Adjust script file: '+ script_file);
        //  MOCK_DI_API
        this.files_content[script_file] = import_mock_api +  this.files_content[script_file];
      }

      /************* 
       * script_test
      **************/ 
      let script_test = script_file.slice(0,-3) + '_test.py' 
      if ((script_test in this.files_content)===false) {
        this.log('Create newer test script: ' + script_test);
        let script_script_test_content = `import script
from utils.mock_di_api import mock_api
from utils.operator_test import operator_test
        
api = mock_api(__file__)
optest = operator_test(__file__)
`;
        // add all config parameters
        script_test_content += '\n# config parameter \n' ;
        this.log('1: ' + script_test_content);
        for (let [key, value] of Object.entries(op_att['config'])) {
          if (key !== '$type' && key !== 'script' ) {
            let param_type = '   # datatype : ' + config_att['properties'][key]['type'] + '\n';
            if (value === null) {value = 'None'};
            switch (config_att['properties'][key]['type']) {
              case "integer":
                script_test_content = script_test_content + 'api.config.' + key + ' = ' + value + param_type; 
                break;
              case "string":
                script_test_content = script_test_content + 'api.config.' + key + ' = \'' + value + '\' ' + param_type; 
                break;
              case "array":
                let arrvalue = "'" + value.join("','") + "'";
                script_test_content = script_test_content + 'api.config.' + key + ' = [' + arrvalue + '] ' + param_type; 
                break;
              default: 
              script_test_content = script_test_content + 'api.config.' + key + ' = \'' + value + '\' ' + param_type; 
            };
          };
        };
        script_test_content += '\nmsg = api.Message(attributes={\'operator\':\''+this.answers.operator+'\'},body=None)\n';
        for (let ip = 0; ip < op_att['inports'].length; ip++) {
          //this.log('Inport: ' + op_att['inports'][ip]['name']);
          script_test_content += script_file.slice(0,-3) + '.on_'+op_att['inports'][ip]['name']+'(msg)\n';
        }
        this.log(script_test_content);
        this.files_content[script_test] = script_test_content
      }

      // package-operator specific folders
      mkdirp.sync(path.join(this.destinationRoot(),'testdata',this.operator_dir));
      mkdirp.sync(path.join(this.destinationRoot(),'operators',this.operator_dir));
      // storing the operator data
      for (const [filename, content] of Object.entries(this.files_content)) {
        this.fs.write(path.join(this.destinationRoot(),'operators',this.operator_dir,filename), content);
      };

    /*
     *  Upload files from DI
    */
    } else if (this.answers.direction == 'U') {
      this.log('***** Upload *****');
      let source_path = path.join(this.destinationRoot(),'operators',this.operator_dir);
      let target_path = path.join(operators_path,this.operator_dir);
      //this.log(source_path + ' -> ' + target_path);

      // comment script file
      let operator_json_raw = fs.readFileSync(path.join(source_path,'operator.json'),'utf8');
      let operator_json = JSON.parse(operator_json_raw);
      let script_file = operator_json['config']['script'].slice(7);
      let script_file_path = path.join(source_path,script_file);
      let script_content = fs.readFileSync(script_file_path,'utf8');

      // remove mock_api
      script_content = script_content.replace(import_mock_api,'');

      fs.writeFileSync(script_file_path, script_content);

      fs.readdirSync(source_path).forEach(file => {
        _vctl_put(this,path.join(source_path,file),path.join(target_path,file));
      });

      // replacements commenting and commenting out
      script_content = script_content.replace(/#\s*from utils.mock_di_api import \*/,'from utils.mock_di_api import *');


      fs.writeFileSync(script_file_path, script_content);

    } else {
      this.log('Unknown direction: (D)ownload or (U)pload. ' + this.answers.direction)
    }
  };
};